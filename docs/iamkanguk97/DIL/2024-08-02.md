# DIL: 모던 자바스크립트 Deep Dive

> 스터디: 월간 CS, https://github.com/monthly-cs/2024-07-modern-javascript-deep-dive  
> 작성일: 2024-08-02  
> 작성자: iamkanguk97

---

## 12.5: 함수 호출

### 12.5.1: 매개변수와 인수

```javascript
function add(x, y) {
  return x + y;
}

// 인수 1,2가 매개변수 x,y에 순서대로 할당된다.
var result = add(1, 2);
```

- 함수가 호출되면 암묵적으로 함수 몸체 내에서 매개변수가 생성되고 undefined로 초기화된 이후에 인수가 순서대로 할당된다.
- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다.
- 만약에 인수를 매개변수 개수보다 더 많이 전달한 경우 개수가 초과한 것인데 이는 `arguments` 객체에 저장된다.
- 참고로 arguments는 함수를 정의할 때 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다.

```javascript
function add(x, y) {
  // arguments(3) -> [2, 5, 10, callee: f, Symbol(Symbol.iterator): f]
  console.log(arguments);

  return x + y;
}

add(2, 5, 10);
```

### 12.5.2: 인수 확인

```javascript
function add(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new TypeError('인수는 모두 숫자여야 한다!');
  }
  return x + y;
}

console.log(add(2));
console.log(add('a', 'b'));
```

- 위와 같은 상황이 발생되기 때문에 타입스크립트와 같은 정적 타입을 선언할 수 있는 자바스크립트의 상위 확장을 도입해서 컴파일 시점에 부적절한 호출을 방지할 수 있도록 하는 것이 좋다.

### 12.5.3: 매개변수의 최대 개수

- 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 하는데 이것은 함수의 사용법을 이해하기 어렵게 만들고 실수발생이 높아진다.
- **이상적인 매개변수는 0개이고, 적을수록 좋다.**
- **매개변수의 개수가 많다 = 함수가 여러가지 일을 한다 = 바람직하지 않음!**
- **함수는 한 가지 일만 해야하고 가급적 작게 만들어야 한다.**
- **그럼에도 불구하고 여러 매개변수가 필요하다면 객체를 인수로 전달하는 것이 좋다. 하지만 주의할 점은 전달한 객체를 함수 내부에서 수정하면 부수효과가 발생한다는 점이다.**

## 12.6: 참조에 의해 전달과 외부 상태의 변경

- 원시 값은 값에 의한 전달, 객체는 참조에 의한 전달 방식으로 동작

```javascript
// primitive: 원시값 / obj: 객체
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // { name: 'Lee' }

// 원시 값은 값 자체가 복사, 객체는 참조값이 복사되어 전달된다.
changeVal(num, person);

console.log(num); // 100
console.log(person); // { name: 'Kim' }
```

- primitive는 원시 값이고 변경 불가능한 값이므로 직접 변경할 수 없어서 재할당을 통해 새로운 원시값으로 대체하였음.
- obj는 객체 값이고 변경 가능한 값이어서 직접 변경할 수 있어서 변경되었다.
- **객체를 함수로 전달하게 되면 부수효과가 발생할 수 있다는 점이 중요하다.**
- 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체하면서 외부 상태가 변경되는 부수효과를 방지할 수 있다.

### 참고) 순수함수

- 순수함수는 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수
- 함수형 프로그래밍: 순수 함수를 통해 부수효과를 최대한 억제해서 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임

## 12.7: 다양한 함수의 형태

### 콜백 함수

```javascript
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}

var logAll = function (i) {
  console.log(i);
};

repeat(5, logAll); // 0 1 2 3 4
```

- **함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 한다.**
- **매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.**
- **고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.**
- **고차함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.**
- **콜백 함수는 고차 함수에 의해 실행되고 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.**

콜백 함수는 비동기 처리 뿐만 아니라 배열 고차함수에서도 사용된다.

### 12.7.5: 순수 함수와 비순수 함수

> 함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 `순수 함수`라고 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 `비순수 함수`라고 한다.
>
> 여기서 말하는 외부 상태는 전역변수, 서버데이터, 파일, 콘솔, DOM 등이 있다.

- **순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수. 즉, 순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해서 함수 내부로 전달된 인수에게만 의존해서 값을 생성해서 반환한다.**
- 만약, 외부 상태에는 의존하지 않고 함수 내부 상태에만 의존한다 해도 그 내부 상태가 호출될 때마다 변화하는 값이라면 순수 함수가 아니다. 예를 들자면 현재 시간이라고 할 수 있을 것 같다.

순수 함수는 최소 하나 이상의 인수를 전달받는다. 인수를 전달받지 않는 함수는 언제나 동일한 값을 반환하니까 상수랑 차이가 없다. 그래서 의미가 별로 없다.

```javascript
var count = 0;

// 순수함수 -> 동일한 인수가 전달되면 언제나 동일한 값을 반환한다
function increase(n) {
  return ++n;
}

count = increase(count); // 1
count = increase(count); // 2

// ==============================

var count = 0; // 전역변수

// 비순수함수 -> 외부 상태에 의존하고 외부 상태를 변경한다
function increase() {
  return ++count;
}

// 비순수함수는 외부 상태를 변경하기 때문에 상태 변화를 추적하기 어려워진다.
increase(); // 1
increase(); // 2
```

- 순수 함수를 쓰도록 하자.
- 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해서 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패더다임이다.
- 조건문, 반복문을 제거해서 복잡성을 해결하고, 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다.
- 결국 순수 함수를 통해 부수 효과를 최대한 억제하는 것이 목표
- 자바스크립트는 멀티 패러다임 언어 => 객체지향 프로그래밍 + 함수형 프로그래밍

---

# 13장: 스코프

## 13.1: 스코프란?

- **모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라고 한다.**
- **스코프 = 식별자가 유효한 범위**

```javascript
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x);
}

foo();

console.log(x);
```

### 코드의 문맥과 환경

- **코드가 어디서 실행되며 주변에 어떤 코드가 있는지 -> 렉시컬 환경**
- **코드의 문맥은 렉시컬 환경으로 이뤄진다 -> 실행 컨텍스트**
- **모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 스코프는 실행 컨텍스트와 깊은 관련!**

위의 코드에서 global 값을 갖는 식별자 x는 전역 스코프, local 값을 갖는 식별자 x는 foo 함수 스코프를 가진다. 참고로 코드의 가장 바깥 영역에 선언된 x 변수는 어디서든 참조할 수 있다.

스코프를 폴더와 디렉토리라고 생각하자. 굉장히 쉽다. 스코프는 네임스페이스다.

```javascript
// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다.
// 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.
function foo() {
  var x = 1;
  var x = 2;
  console.log(x); // 2
}
foo();

// let이나 const로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.
function bar() {
  let x = 1;
  let x = 2; // SyntaxError
}
bar();
```

## 13.2: 스코프의 종류

> 전역 스코프와 지역 스코프

### 13.2.1: 전역과 전역 스코프

- 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 되고, 이는 모든 곳에서 참조가 가능하다.
- 함수 내부에서도 참조가 가능하다.

### 13.2.2: 지역과 지역 스코프

- 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

## 13.3: 스코프 체인

- 스코프가 계증척으로 연결된 것을 스코프 체인이라고 한다.
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 그래서, 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있는 것이다.

### 렉시컬 환경

스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. 전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다.

### 13.3.1: 스코프 체인에 의한 변수 검색

> **상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만, 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수는 없다.**

## 13.4: 함수 레벨 스코프

C나 자바 등을 비롯한 대부분의 프로그래밍 언어는 함수 몸체뿐만 아니라 모든 코드블록이 지역 스코프를 만든다. 이러한 특성을 블록 레벨 스코프라고 한다.

**하지만, var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프라고 부른다.**

```javascript
var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드블록만을 지역 스코프로 인정한다.
  // 함수 밖에서 var 키워드로 선언된 변수는 모두 전역변수다. 그래서 x는 전역변수
  // 이미 선언된 전역변수가 있어서 중복 선언되었다.
  var x = 10;
}

console.log(x); // 10
```

```javascript
var i = 10;

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}
console.log(i); // 5
```

- var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정
- ES6에서 도입된 let,const는 블록 레벨 스코프를 지원한다.

## 13.5: 렉시컬 스코프

```javascript
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo();
bar();
```

### CASE-1) 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.

- bar 함수의 상위 스코프는 foo 함수의 지역 스코프와 전역 스코프
- 동적 스코프
- 함수를 정의하는 시점에 함수가 어디서 호출될지 알 수 없다.
- 그래서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 해서 동적 스코프라고 부른다.

### CASE-2) 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.

- bar 함수의 상위 스코프는 전역 스코프
- `렉시컬 스코프 또는 정적 스코프`
- 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라고 부른다.
- **자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.**

**자바스크립트는 렉시컬 스코프를 따르기 때문에 함수를 어디스 정의했는지에 따라 상위 스코프를 결정한다. 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향을 주지 않는다는 것이고, 함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.**

**함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다. 함수 정의(함수 선언문 또는 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다.**
