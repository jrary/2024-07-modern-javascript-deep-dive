# DIL: 모던 자바스크립트 Deep Dive

> 스터디: 월간 CS, https://github.com/monthly-cs/2024-07-modern-javascript-deep-dive  
> 작성일: 2024-07-27  
> 작성자: iamkanguk97

---

## 6.1: 숫자 타입

- C나 Java의 경우에는 정수와 실수를 구분해서 자료형을 제공한다!(int, long, float, double)
- **하지만 자바스크립트는 하나의 숫자 타입만 존재한다.**

ECMAScript 사양에 따르면 숫자 타입은 배정밀도 64비트 부동소수점 형식을 따른다. 다시 말해서, 모든 수를 실수로 처리하고 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다는 것이다.

정수/실수/2진수/8진수/16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다.

## 6.2: 문자열 타입

- 문자열은 0개 이상의 16비트 유니코드 문자의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.
- 자바스크립트에서 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다.
- C는 문자열 타입이 없고 문자의 배열로 문자열을 표현하고, 자바는 문자열을 객체로 표현한다. **하지만 자바스크립트의 문자열은 원시 타입이고 변경 불가능한 값이다.**

## 6.3: 템플릿 리터럴

- ES6부터 도입된 개념
- 작은,큰따옴표 대신 백틱을 사용해서 표현한다.
- 멀티라인 문자열, 표현식 삽입, 태그드 템플릿

### 6.3.1: 멀티라인 문자열

**일반적으로 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다. 그래서 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용해야 한다.**

```javascript
var str = 'Hello
world.';
// SyntaxError 발생!
```

예를 들어, 줄바꿈과 들여쓰기가 적용된 HTML 문자열은 이스케이프 시퀀스를 사용해서 작성하지만, 일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되고 모든 공백도 있는 그대로 적용된다.

### 라인 피드(LF)와 캐리지 리턴(CR)

개행 문자에는 라인 피드와 캐리지 리턴이 있다. 이는 과거 타자기에서 커서를 제어하는 방식에서 비롯된 것이다. **라인 피드(\n)는 커서를 정지한 상태에서 종이를 한 줄 올리는 것이고, 캐리지 리턴(\r)은 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것이다.**

초창기 컴퓨터는 출력을 프린터로 수행했는데 개행을 위해서 라인 피드와 캐리지 리턴을 모두 사용했다. 그래서 CRLF(\r\n)로 커서를 맨 앞으로 이동시키고 종이를 한 줄 올리는 방식으로 개행했다.

윈도우는 CR+LF로 새 줄을 나타내고 유닉스는 LF로 새 줄을 나타낸다. MacOS는 버전 9까지는 CR로 새 줄을 나타냈지만 버전 10부터는 LF을 사용한다. 그래서 다른 운영체제에서 작성한 텍스트 파일은 서로 개행 문자를 인식하지 못하지만 태부분의 텍스트 에디터는 운영체제에 맞게 개행 문자를 자동으로 변환해줘서 큰 문제는 없다.

자바스크립트에서 라인피드와 캐리지 리턴은 모두 개행을 의미하지만 캐리지 리턴으로 개행하는 경우는 거의 없고 라인 피드를 사용해서 개행한다.

## 6.5: undefined 타입

var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화된다. **다시 말해서, 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태(대부분 비어있지 않고 쓰레기 값이 들어있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화한다.**

**`undefined`는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는, 초기화되지 않은 변수라는 것을 알 수 있다.**

그래서 우리는 변수에 값이 없다는 것을 명시하고 싶을 때는 undefined가 아닌 null을 할당하는 것이 좋다.

## 6.6: null 타입

- 변수에 값이 없다는 것을 의도적으로 명시할 때 사용할 수 있다.
- 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.

```javascript
var foo = 'Lee';

// 이전 참조 제거. foo 변수는 더 이상 'Lee'를 참조하지 않는다.
foo = null;
```

- 이전에 할당되어 있던 값에 대해 참조를 명시적으로 제거한다. 그러면서 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.
- 함수가 유효한 값을 반환할 수 없는 경우에는 명시적으로 null을 반환할 수도 있다.

## 6.7: 심벌 타입

- Symbol 타입은 ES6에서 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다.
- 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.
- 심벌 이외의 원시 값들은 리터럴을 통해 생성하지만 심벌은 Symbol 함수를 호출해서 생성한다. 이 때 생성된 심벌 값은 외부에 노출되지 않고, 다른 값과 절대 중복되지 않는 값이다.

```javascript
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); // value;
```

## 6.8: 객체 타입

- 자바스크립트 = 원시 타입 + 객체 타입
- **자바스크립트는 객체 기반의 언어이고, 자바스크립트를 이루고 있는 거의 모든 것이 객체라는 것이 중요한 점.**

## 6.9: 데이터 타입의 필요성

### 6.9.1: 데이터 타입에 의한 메모리 공간의 확보와 참조

```javascript
var score = 100;
```

위 코드가 실행되면 컴퓨터는 숫자 값 100을 저장하기 위해서 메모리 공간을 확보한 다음 확보된 메모리에 숫자 값 100을 2진수로 저장한다.
이런 처리를 하기 위해서는 숫자 값을 저장할 때 확보해야 할 메모리 공간의 크기를 알아야 하는데 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.

다시 말해서, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.

리터럴 100은 숫자 타입의 값으로 해석하고 해당 값을 저장하기 위해서 8바이트의 메모리 공간을 확보하고 100을 2진수로 저장한다.

### 참고 사항

ECMAScript 사양은 문자열과 숫자 타입 외의 데이터 타입의 크기를 명시적으로 규정하고 있지는 않다. 그래서 문자열과 숫자 타입을 제외하고 데이터 타입에 따라 확보되는 메모리 공간은 자바스크립트 엔진 제조사에 따라 구현이 다를 수 있다.

ECMAScript 사양에 숫자 타입은 배정밀도 64비트 부동소수점 형식을 사용한다고 명시되어있고 배정밀도 64비트 부동소수점 형식은 8바이트로 숫자를 표현한다.

score 식별자를 통해서 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있다. 정확히 말하자면 숫자 값 100이 저장되어 있는 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 수 있다.

이 때 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기(메모리 셀의 개수(바이트 수))를 알아야 한다. score의 경우는 저장되어 있는 값이 숫자 타입이기 때문에 8바이트 단위로 읽어 들이지 않으면 값이 훼손된다.

### 컴퓨터는 어떻게 한 번에 읽어 들여야 할 메모리 셀의 크기를 아는걸까?

변수에는 숫자 타입의 값이 할당되어 있어서 자바스크립트 엔진은 score 변수를 숫자 타입으로 인식한다. 숫자 타입은 8바이트 단위로 저장되기 때문에 score 변수를 참조하면 8바이트 단위로 메모리 공간에 저장된 값을 읽어들인다.

### 심벌 테이블

컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해서 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

### 6.9.2: 데이터 타입에 의한 값의 해석

메모리에서 읽어 들인 2진수를 어떻게 해석할까? 모든 값은 데이터 타입을 가지고 메모리에 2진수(비트의 나열)로 저장된다. 메모리에 저장된 값은 데이터의 타입에 따라 다르게 해석될 수 있다. `0100 0001`을 숫자로 해석하면 65고, 문자로 해석하면 A이다.

앞의 예제어스 score 변수는 숫자 타입의 값이기 때문에 score 변수를 참조하면 메모리 공간의 주소에서 읽어들인 2진수를 숫자로 해석한다.

### 데이터 타입이 필요한 이유

- 값을 저장할 때 확보해야 하는 **메모리 공간의 크기를 결정**하기 위해
- 값을 참조할 때 한 번에 **읽어 들여야 하는 메모리 공간의 크기를 결정**하기 위해
- **메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정**하기 위해

## 6.10: 동적 타이핑

### 6.10.1: 동적 타입 언어와 정적 타입 언어

#### 정적 타입 언어(C, Java)

- 변수를 선언할 때 변수에 할당할 수 있는 값의 종류(데이터 타입)를 사전에 선언해야 한다. (명시적 타입 선언)
- 컴파일 시점에 타입 체크를 수행하는데 타입 체크를 통과하지 못했다면 에러를 발생시키고 프로그램의 실행 자체를 막는다.
- 타입의 일관성을 강제하면서 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다.
- C, C++, Java, Kotlin, Go 등

### 동적 타입 언어(JavaScript)

- 자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다. 하지만 var, let, const 키워드를 사용해 변수를 선언한다.
- 미리 선언한 데이터 타입의 값만 할당할 수 있는게 아니다, 처음에 숫자를 할당하고 나중에 문자열을 할당할 수도 있다.

**자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라고 하고, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입 언어라고 부른다.**

### 6.10.2: 동적 타입 언어와 변수

동적 타입 언어가 장점도 있지만 단점도 분명히 존재한다. 변수의 값이 언제든 변경될 수 있어서 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다. 그리고, 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있어서 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 선언할 수 없다.

**즉, 동적 타입 언어는 유연성은 높지만, 신뢰성이 떨어진다.**

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. 동적 타입 언어인 자바스크립트는 타입을 잘못 예측해서 오류가 발생할 가능성이 크고, 이는 변수의 개수가 많아지면 많아질수록 오류가 발생할 확률도 높아진다는 것이다.
- 변수의 유효 범위(스코프)는 최대한 좁게 만들어서 변수의 부작용을 억제해야 한다.
- 전역 변수는 최대한 사용하지 말자. 어디서든지 참조 및 변경이 가능한 전역 변수는 의도치 않게 값이 변경될 가능성이 높고, 다른 코드에 영향을 줄 가능성도 높다.
- 변수보다는 상수를 활용해서 값의 변경을 억제하자.
- 변수의 이름은 목적이나 의미를 파악할 수 있도록 네이밍하자. 이는 협업과 생산성 향상에 도움을 준다.

<br/>

# 7장: 연산자

## 7.1: 산술 연산자

> 산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해서 새로운 숫자 값을 만드는데, 산술 연산이 불가능하면 NaN을 반환한다.

### 7.1.2: 단항 산술 연산자 (++, --, +, -)

- **++, -- 같은 경우에는 피연산자의 값을 변경하는 부수 효과(Side Effect)가 있다는 것을 명심하자.**
- 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환한다. 부수효과는 없다.
  - `+'Hello' = NaN`

### 7.1.3: 문자열 연결 연산자

> `+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 이 외의 경우에는 산술 연산자로 동작한다.

```javascript
// 문자열 연결 연산자
'1' + 2; // '12'
1 + '2'; // '12'

// 산술 연산자
1 + 2; // 3

// true는 1로 타입 변환한다.
1 + true; // 2

// false는 0으로 타입 변환한다.
1 + false; // 0

// null은 0으로 타입 변환한다.
1 + null; // 0

// undefined는 숫자로 타입 변환이 되지 않는다.
+undefined; // NaN
1 + undefined; // NaN
```

위의 예제에서 주목할 점은 **개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 것**이다.
`1 + true`를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입을 숫자 타입으로 강제 변환 후 연산을 수행한다.

이를 `암묵적 타입 변환(Implicit coercion)` 또는 `타입 강제 변환(Type Coercion)` 이라고 한다. +/- 단항 연산자도 암묵적 타입 변환을 수행한다.

## 7.2: 할당 연산자

### 할당문은 표현식인 문일까 표현식이 아닌 문일까?

```javascript
var x;
console.log((x = 10)); // 10
```

할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다. 하지만 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가한다. 위 예제에서는 10으로 평가된다.

그리고 할당문을 다른 변수에 할당할 수도 있다.

```javascript
var a, b, c;

// 연쇄 할당. 오른쪽에서 왼쪽으로 진행
// c = 0: 0으로 평가된다.
// b = 0: 0으로 평가된다.
// a = 0: 0으로 평가된다.
a = b = c = 0;
```

## 7.3: 비교 연산자

### 7.3.1: 동등/일치 비교 연산자

- 동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시키고 같은 값인지 비교한다.
  - `5 == '5'` (true)

사용할 때는 == 보다는 ===을 사용하려고 하자. 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한해서 true를 반환한다. 암묵적 타입 변환을 하지 않고 값을 비교한다. 단, NaN을 주의하자.

```javascript
// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // false
```

그리고, 숫자 0도 주의해야 한다. 자바스크립트에는 양의 0과 음의 0이 있는데 이를 비교하면 true를 반환한다.

```javascript
0 === -0; // true
0 == -0; // true
```

### Object.is 메서드

ES6에서 도입된 Object.is 메서드는 예측 가능한 정확한 비교 결과를 반환한다. 그 외에는 일치 비교 연산자와 동일하게 작동한다.

```javascript
-0 === +0; // true
Object.is(-0, +0); // false

NaN === NaN; // false
Object.is(NaN, NaN); // true
```

## 7.4: 삼항 조건 연산자

**삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.**

## 7.5: 논리 연산자

논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과가 항상 불리언 값이 아닐 수도 있다. 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

```javascript
'Cat' && 'Dog'; // 'Dog'
```

### 드모르간의 법칙

논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한눈에 이해하기 어려울 수 있는데 이 때 드모르간의 법칙을 이용해서 더욱 가독성있는 표현식으로 변환하자.

```javascript
!(x || y) === (!x && !y);
!(x && y) === (!x || !y);
```

## 7.6: 쉼표 연산자

```javascript
var x, y, z;
(x = 1), (y = 2), (z = 3); // 3
```

왼쪽 피연산자부터 차례대로 피연산자를 평가하고, 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

## 7.8: typeof 연산자

- 피연산자의 데이터 타입을 문자열로 반환한다.
- `string / number / boolean / undefined / symbol / object / function` 중 하나를 반환한다.
- null은 object를 반환한다는 점은 잊지말자. (자바스크립트의 첫 번째 버그 -> 기존 코드에 영향을 줄 수 있기 땜에 수정X)
  - 그래서 값이 null 타입인지 확인할 때는 typeof 보다는 === 연산자를 사용하자.
- 그리고, 선언하지 않은 식별자를 typeof 연산자로 연산해보면 ReferenceError가 아닌 Undefined를 출력한다.

```javascript
var foo = null;

typeof foo === null; // false
foo === null; // true

typeof helloworld; // helloworld 식별자를 선언한 적 없지만 undefined를 반환
```

## 7.11: 연산자의 부수효과

**부수효과가 있는 연산자는 할당 연산자(=), 증감소 연산자(++, --), delete 연산자이다.**

## 7.12: 연산자 우선순위

- 1순위: ()
- 2순위: new(매개변수 존재), ., [](프로퍼티 접근), ()(함수 호출), ?.(옵셔널 체이닝 연산자)
- 3순위: new(매개변수 미존재)
- 4순위: x++, x--
- 5순위: !x, +x, -x, ++x, --x, typeof, delete
- 6순위: \*\*(이항 연산자 중에서 우선순위가 가장 높다)
- 7순위: \*, /, %
- 8순위: +, -
- 9순위: <, <=, >, >=, in, instanceof
- 10순위: ==, !=, ===, !==
- 11순위: ??(null 병합 연산자)
- 12순위: &&
- 13순위: ||
- 14순위: ? ... : ...
- 15순위: 할당 연산자(=, +=, -=, ...)
- 16순위: ,

위의 내용들을 다 기억하기는 힘드니까 연산자 우선순위가 가장 높은 그룹 연산자를 사용해서 우선순위를 명시적으로 조절하자.

<br/>

# 8장: 제어문

> 제어문은 코드의 흐름을 이해하기 어렵게 만들어서 가독성을 해치는 단점이 있다. 가독성이 좋지 않은 코드는 오류를 발생시키는 원인이 된다. 그래서 나중에 forEach, map, filter, reduce와 같은 고차 함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제해서 복잡성을 해결하려고 노력한다.

## 8.2: 조건문

- 삼항 조건 연산자는 값으로 평가되는 표현식을 만들어서, 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 하지만 if-else문은 표현식이 아닌 문이라서 값처럼 사용할 수 없고 변수에 할당할 수 없다.

### 8.2.2: Switch문

- break문은 꼭 사용하는 것이 원칙이다. default에는 사용하지 않아도 된다.
- 하지만 break를 생략한 폴스루가 유용한 경우도 있다.

```javascript
var year = 2000; // 2000년은 윤년으로 2월이 29일이다.
var month = 2;
var days = 0;

switch (month) {
  case 1:
  case 3:
  case 5:
  case 7:
  case 8:
  case 10:
  case 12:
    days = 31;
    break;
  case 4:
  case 6:
  case 9:
  case 11:
    days = 30;
    break;
  case 2:
    // 윤년 계산 알고리즘 진행~
    days = (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0 ? 29 : 28;
    break;
  default:
    console.log('Invalid Month');
}
```

if-else로 해결할 수 있다면 switch 보다는 if-else를 사용하는 것이 좋다. 하지만 조건이 많아서 if-else 보다 switch를 사용했을 때 가독성이 더 좋다면 switch를 사용하는 것도 좋다.

## 8.4: break문

### 레이블 문: 식별자가 붙은 문

```javascript
// foo라는 레이블 식별자가 붙은 레이블 문
foo: console.log('foo');
```

레이블 문은 프로그램의 실행 순서를 제어하는데 사용한다. switch문의 case와 default도 레이블 문이다. 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.

```javascript
foo: {
  console.log(1);
  break foo; // foo 레이블 블록문을 탈출
  console.log(2);
}
console.log('Done!');
```

<br/>

# 9장: 타입 변환과 단축 평가

## 9.1: 타입 변환이란?

- 자바스크립트의 모든 값은 타입이 있다.
- 개발자가 의도적으로 값의 타입을 변환하는 것을 `명시적 타입 변환` 또는 `타입 캐스팅`이라고 한다.

```javascript
var x = 10;

// 명시적 타입 변환 (숫자를 문자열로 타입 캐스팅)
var str = x.toString();
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아니다
console.log(typeof x, x); // number 10
```

개발자의 의도와 상관없이 표현식을 평가하는 중에 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되기도 하는데 이를 `암묵적 타입 변환` 또는 `타입 강제 변환`이라고 부른다.

```javascript
var x = 10;

// 암묵적 타입 변환
// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.
var str = x + '';
console.log(typeof str, str); // string 10
```

- **원시 값은 변경 불가능한 값이기 때문에 변경할 수 없다.**
- **타입 변환은 기존 원시 값을 사용해서 다른 타입의 새로운 원시 값을 생성하는 것을 말한다.**

우리는 동료가 작성한 코드를 정확히 이해할 수 있어야 하고, 자신이 작성한 코드도 동료가 쉽게 이해할 수 있어야 한다. 그렇기 때문에 타입 변환이 어떻게 동작하는지 정확히 이해하고 사용하는 것이 좋다.

## 9.2: 암묵적 타입 변환

> **자바스크립트 엔진이 표현식을 평가할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려해서 암묵적으로 데이터 타입을 강제 변환하는 경우를 말한다.**

```javascript
'10' + 2; // '102' (모두 문자열)
5 * '10'; // 50 (모두 숫자)
!0; // true
if (1) {
}
```

**자바스크립트는 이러한 상황에서도 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다.**

### 9.2.1: 문자열 타입으로 변환

> **`+` 연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환을 진행한다.**

```javascript
0 + ''; // '0'
-0 + ''; // '0'
1 + ''; // '1'
-1 + ''; // '1'
NaN + ''; // 'NaN'
Infinity + ''; // 'Infinity'
-Infinity + ''; // '-Infinity'

true + ''; // 'true'
false + ''; // 'false'

null + ''; // 'null'
undefined + ''; // 'undefined'

Symbol() + ''; // TypeError: Cannot convert a symbol value to a string

({}) + ''; // "[object Object]"
Math + ''; // "[object Math]"
[] + ''; // ""
[10, 20] + ''; // "10,20"
(function () {}) + ''; // "function(){}"
Array + ''; // "function Array() { [native code] }
```

### 9.2.2: 숫자 타입으로 변환

```javascript
1 - '1'; // 0
1 * '10'; // 10
1 / 'one'; // NaN -> 산술 연산을 수행할 수 없기 때문에

'1' > 0; // true -> 비교 연산자도 모두 숫자 타입이어야 하기 때문에 숫자 타입이 아닌 연산자를 숫자 타입으로 변환
```

```javascript
+''; // 0
+'0'; // 0
+'1'; // 1
+'string'; // NaN

+true; // 1
+false; // 0

+null; // 0
+undefined; // NaN

+Symbol(); // TypeError: Cannot convert a symbol value to a number

+{}; // NaN
+[]; // 0
+[10, 20]; // NaN
+function () {}; // NaN
```

**참고로 빈 문자열, 빈 배열, null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아서 NaN이 된다는 것에 항상 주의하자.**

### 9.2.3: Boolean 타입으로 변환

> **자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환을 진행한다.**

- 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.
- 제어문의 조건식과 같이 값으로 평가되어야 할 문맥에서 Truthy는 true, Falsy는 false로 암묵적 타입 변환 진행.
- Falsy한 값들: `false, undefined, null, 0과 -0, NaN, 빈 문자열('')`

## 9.3: 명시적 타입 변환

> **개발자의 의도에 따라 명시적으로 타입을 변경하는 방법이다. 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법, 빌트인 메서드를 사용하는 방법, 암묵적 타입 변환을 사용하는 방법 등이 있다.**

### 표준 빌트인 생성자 함수와 빌트인 메서드

표준 빌트인 생성자 함수와 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 함수다. 표준 빌트인 생성자 함수는 객체를 생성하기 위한 함수이고, new 연산자와 함께 호출된다. 표준 빌트인 메서드는 자바스크립트에서 기본적으로 제공하는 빌트인 객체의 메서드이다.

### 9.3.1: 문자열 타입으로 변환

문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메서드 사용하는 방법
- 문자열 연결 연산자를 사용하는 방법

```javascript
String(1);
String(NaN);
String(Infinity);

String(true);
String(false);

(1).toString();
NaN.toString();
Infinity.toString();

true.toString();
false.toString();

1 + '';
NaN + '';
Infinity + '';
true + '';
false + '';
```

### 9.3.2: 숫자 타입으로 변환

숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수를 사용하는 방법 (문자열만 숫자 타입으로 변환 가능)
- `+` 단항 산술 연산자를 이용하는 방법
- `*` 산술 연산자를 이용하는 방법

### 9.3.3: 불리언 타입으로 변환

불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- ! 부정 논리 연산자를 두 번 사용하는 방법

## 9.4: 단축 평가

### 9.4.1: 논리 연산자를 사용한 단축 평가

**논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 즉, 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.**

```javascript
'Cat' && 'Dog'; // Dog
```

- 논리곱 연산자는 두 개의 피연산자 모두 true로 평가될 때 true를 반환한다. 참고로 논리곱 연산자는 왼쪽에서 오른쪽으로 평가를 진행한다.
- **논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자를 반환한다. (Cat은 true, Dog를 그대로 반환한다)**
- **물론 논리합 연산자도 마찬가지로 동작한다. (Cat || Dog -> Cat이 true이기 때문에 그대로 Cat을 반환한다)**

**논리곱 연산자와 논리합 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다. 이를 `단축 평가`라고 한다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.**

- `true || anything -> true`
- `false || anything -> anything`
- `true && anything -> anything`
- `false && anything -> false`

단축 평가를 사용하면 if문을 대체할 수 있다.

```javascript
var done = true;
var message = '';

if (done) message = '완료';

message = done && '완료';
console.log(message); // 완료

// ==============================

var done = false;
var message = '';

if (!done) message = '미완료';

message = done || '미완료';
console.log(message); // 미완료
```

### 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때

객체는 key와 value로 구성된 property의 집합이다. 만약 객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 null 또는 undefined인 경우 객체의 프로퍼티를 참조하면 TypeError가 발생한다.

```javascript
var elem = null;
var value = elem.value; // TypeError: Cannot read property 'value' of null

var elem = null;
var value = elem && elem.value; // null
```

위 예제와 같이 단축 평가를 사용하게 되면 에러를 방지할 수 있다.

### 함수 매개변수에 기본값을 설정할 때

함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다. 이 때 단축평가를 사용해서 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.

```javascript
function getStringLength(str) {
  str = str || '';
  return str.length;
}

getStringLength(); // 0
getStringLength('hi'); // 2

// ES6의 매개변수의 기본값 설정
function getStringLength(str = '') {
  return str.length;
}

getStringLength(); // 0
getStringLength('hi'); // 2
```

### 9.4.2: 옵셔널 체이닝 연산자

**ES11(ECMAScript2020)에서 도입된 옵셔널 체이닝 연산자 `?.`는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.**

```javascript
/**
 * elem이 null 또는 undefined이면 undefined를, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
 */
var elem = null;
var value = elem?.value; // undefined
```

이는 객체를 가리키기를 기대하는 변수가 null 또는 Undefined가 아닌지를 확인하고 프로퍼티를 참조할 때 유용하다. 이게 있기 전에는 논리 연산자 &&를 통해 변수가 null 또는 undefined인지 확인했다.

```javascript
var str = '';
var length = str && str.length;
var length2 = str?.length;

console.log(length); // ''
console.log(length2); // 0
```

위 소스의 차이점은 뭘까?

- 논리 연산자 &&는 좌항 피연산자가 false로 평가되는 falsy 값이면 좌항 피연산자를 그대로 반환한다. (단, 0이나 ''은 객체로 평가될 때도 있다)
- 옵셔널 체이닝 연산자 ?.는 좌항 피연산자가 falsy 값이라도 null이나 undefined가 아니면 우항의 프로퍼티 참조를 이어간다.

### 9.4.3: null 병합 연산자

**ES11에서 도입된 null 병합 연산자인 ??는 좌항의 피연산자가 null/undefined인 경우에는 우항의 피연산자를 반환하고, 그렇지 않은 경우에는 좌항의 피연산자를 반환한다. 보통 변수에 기본값을 설정할 때 유용하다.**

```javascript
var foo = null ?? 'default string';
console.log(foo); // default string

var foo = '' || 'default string';
console.log(foo); // default string

var foo = '' ?? 'default string';
console.log(foo); // ''
```
