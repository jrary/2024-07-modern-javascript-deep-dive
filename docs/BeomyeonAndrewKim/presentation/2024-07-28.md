https://iris-growth-a97.notion.site/04-27d5cdae115745a8a0802421a0bf49db?pvs=4

# 04장 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

자바스크립트 엔진이 10+20 이라는 식의 의미를 해석하면 + 연산을 수행하기 위해서 10과 20이라는 숫자 값(피연산자)을 기억한다.

컴퓨터는 연산(CPU)과 기억(Memory)을 수행하는 부품이 나누어져 있기 때문에 피연산자 값은 메모리주소에 저장되고, CPU는 이 값을 읽어 들여 연산을 수행한다.

연산 결과로 생성된 숫자 값 30도 메모리 주소에 저장되는데 이 값을 재사용하려면 주소를 통해 메모리 공간에 직접 접근해야하지만, 이는 치명적 오류를 야기하는 매우 위험한 방법이기에 자바스크립트는 **개발자의 직접적인 메모리 제어를 허용하지 않는다**. 따라서 30이라는 값은 재사용이 불가능하다.

만약 직접적인 메모리 제어를 허용하더라도 코드가 실행될 때마다 값이 저장될 메모리 주소는 변경되므로, 코드 실행 이전에는 메모리 주소의 값을 알 방법이 없으므로 직접 접근하는 방법은 올바른 방법이 아니다.

프로그래밍 언어는 기억하고싶은 값을 메모리에 **저장**하고, 저장된 값을 읽어들여 **재사용**하기 위해 "변수"라는 메커니즘을 제공한다.

> 변수는 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체 식별하기 위해 붙인 이름**
> 

변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다. 따라서 변수를 통해 직접적인 메모리 제어 없이 안전하게 값에 접근할 수 있다!

- 변수에 값을 저장하는 것을 **할당(assignment-대입, 저장)이라 하고,** 변수에 저장된 값을 읽어 들이는 것을 **참조(reference)**라고 한다.
- 변수 이름을 이용해서 참조를 요청하면, 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.

## 4.2 식별자

> 변수 이름을 식별자(identifier)라고도 하며, 어떤 값을 구별해서 **식별할 수 있는 고유한 이름**
> 

식별자는 값이 저장되어 있는 메모리 주소와 매핑관게를 맺으며, 이 **매핑 정보도 메모리에 저장**되어야 한다!

식별자는 값이 아니라 **메모리 주소를 기억**하고있으며, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.

## **4.3 변수 선언**

변수 선언은 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장하도록 준비하는 것이다. 확보된 메모리 공간은 확보가 해제되기 전까지 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전히 공간을 사용할 수 있다.

변수를 사용하려면 선언이 반드시 필요하며 var, const, let 키워드를 사용한다. let과 const는 ES6에서 도입된 키워드로, var 키워드의 함수 레벨 스코프 지원 등의 단점을 보완하기 위해 등장한 키워드이다.

4장에서는 우선 var키워드를 살펴본다. var 키워드의 변수 선언 과정을 살펴보자.

1. var score; 의 변수 선언문은 변수 이름을 등록하고, 값을 저장할 메모리 공간을 확보한다. **(선언 단계)**
2. 변수는 선언되었지만 아직 값은 할당되지 않았다. 이때 메모리 공간은 비어있지 않고, 확보된 메모리 공간에는 자바스크립트 엔진에 의해 undefined라는 값으로 암묵적으로 할당되어 초기화된다! **(초기화 단계)**

일반적으로 **초기화**란 변수가 선언된 이후 **최초로 값을 할당**하는 것을 의미한다.

만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 앱이 사용했던 값이 남아있을 수 있는데, 이 값을 쓰레기값(garbage value)라 한다. 이러한 쓰레기 값을 참조하는것을 방지하기 위해 var 키워드는 암묵적으로 초기화를 수행한다.

## **4.4 변수 선언의 실행 지점과 변수 호이스팅**

```jsx
console.log(score);// undefinedvar score;// 변수 선언문
```

위 코드를 살펴보면 변수 선언문보다 변수를 참조하는 코드가 앞에 있지만, 인터프리터에 의해 한 줄씩 순차적으로 코드가 실행되는 과정에서 참조 에러가 발생하지 않고 undefined가 출력된다.

- > 이는 변수 선언이 소스코드가 순차적으로 실행되는 시점(런타임)이 아니라 그 이전단계(소스코드의 평가과정)에서 먼저 실행되기 때문이다! 소스코드의 평과과정에서는 변수, 함수 선언문 등을 소스코드에서 찾아내 먼저 실행하고, 이 과정이 끝나면 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

> 이처럼 변수 선언문이 런타임 이전단계에서 먼저 실행되어
> 
> 
> **코드의 선두로 끌어올려진 것 처럼 동작하는 자바스크립트 고유의 특징**
> 
> **변수 호이스팅**
> 

; var, let, const, function, class등의 키워드를 사용해서 선언하는 모든 식별자는 런타임 이전단계에서 실행되기 때문에 모두 호이스팅된다고 할 수 있다.

## **4.5 값의 할당**

변수에 값을 할당할 때는 할당 연산자 "="를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

```csharp
var score;// 변수 선언
score = 80;// 값의 할당var score = 80;// 변수 선언 + 값의 할당
```

위 코드와 같이 변수 선언과 값의 할당을 2개의 문으로 나누어 표현할 수도 있고, 하나의 문으로 단축하여 표현할 수도 있다.

두가지 표현 방식은 정확히 동일하게 동작하고, 이는 하나의 문으로 단축 표현해도 자바스크립트 엔진은 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다는 것이다.

이 때 변수 선언은 **런타임 이전에 먼저 실행**되지만, 값의 할당은 소스코드가 순차적으로 실행되는 시점인 **런타임에 실행**된다!

> 변수에 값을 할당할 때는 이전 값 undefined(초기화된 값)가 저장되어 있던 메모리 공간을 지우고 할당값을 저장하는 것이 아니라,
> 
> 
> **새로운 메모리 공간을 확보**
> 
> **그곳에 할당 값을 저장**
> 

## **4.6 값의 재할당**

```
var score = 80;
score = 90; // 값의 재할당
```

위 코드와 같이 var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. (엄밀이 말하면 변수를 선언 후 초기화하는 과정도 재할당이라 할 수 있다.)

처음 변수에 값을 할당할 때와 마찬가지로 이전 값 80이 저장되어있던 메모리 공간을 지우고 90을 저장하는것이 아니라, 새로운 메모리 공간을 확보하고 그 메모리 공간에 90을 저장한다!

score변수의 이전 값인 undefined와 80은 아무도 사용하지 않는 필요하지 않은 값이므로 이 값들은 가비지 콜렉터에 의해 특정 시점에 메모리에서 자동 해제된다.

가비지 콜렉터는 어플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능이다. 자바스크립트는 가비지 콜렉터를 내장하고있는 매니지드 언어로서 **메모리 누수를 방지**한다. (언매니지드 언어에는 개발자가 명시적으로 메모리를 할당하고 해제할 수 있는 c언어가 있다.)

# 5장 표현식과 문

## 5.1 값

용어의 의미를 정확히 설명할 수 없다면 개념을 제대로 이해하지 못한 경우가 많다. 값(value)은 식(표현식)이 평가(evaluate)되어 생성된 결과를 말한다. 모든 값은 데이터 타입을 가지며, 이에 따라 다르게 해석될 수 있다. 예를 들어 이진수 01000001은 숫자 65에 해당하지만 문자 'A'로도 해석할 수 있다. 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간, 또는 해당 공간을 식별하기 위해 붙인 이름이다.

```
var sum = 10 + 20;
```

10 + 20은 30으로 sum이라는 변수에 최종 할당되는 값은 30이다. 10 + 20은 할당 이전에 평가되어 값을 생성해야 한다.

## 5.2 리터럴

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다. 자바스크립트 엔진은 코드가 실행되는 런타임 시점에 리터럴을 평가해 값을 생성한다. 즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법이다.

## 5.3 표현식

표현식은 값으로 평가할 수 있는 문(statement)이다. 즉, 표현식이 평가(실행)되면 새로운 값을 생성하거나 기존 값을 참조한다. 표현식은 리터럴, 식별자(변수, 함수), 연산자, 함수 호출 등의 조합으로 다양하게 이뤄질 수 있다. 즉, 값으로 평가(실행)될 수 있는 문은 모두 표현식이다.

```jsx
var num = 1;
if( 2 === ( num + 1 ) ) {
  console.log("똑같다")
}
```

※ 표현식을 값 대신?: 표현식은 문법적으로 값이 위치할 수 있는 자리에 위치할 수 있고, 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수도 있다.   위의 예시에서 if 문 내에서 숫자 2와 ( num + 1 )을 동등 비교하고 있는데 ( num + 1 ) 은 표현식으로 값 2로 평가되기 때문에 정상동작한다.

## 5.4 문

문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다. 문은 여러 토큰으로 구성되며, 이는 컴퓨터에 내리는 명령이 되기 때문에 문을 명령문이라고도 부른다.

※ 토근이란?: 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다. 즉, 기호 하나, 연산자 하나하나가 모두 토큰이다.

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

세미콜론(;)은 문의 종료를 나타내고 대부분의 프로그래밍 언어는 반드시 코드 끝에 붙여야 한다. 하지만 자바스크립트 엔진은 세미콜론 자동 삽입 기능이 암묵적으로 수행되기 때문에 세미콜론을 옵션으로 보고 생략해도 된다. 원칙적으로 if문, for문, 함수 등의 0개 이상의 문을 중괄호로 묶은 코드 블록은 해당 코드블록 하나하나가 자체 종결성을 갖는다고 보기 때문에 세미콜론을 붙이지 않는다. 하지만 동작을 제대로 예측하지 못해 오류가 발생할 수 있으므로 세미콜론을 가급적 사용하도록 권장하는 분위기다.

```jsx
function foo () {
  return
  {}
}
```

※ 자바스크립트 엔진의 암묵적인 동작(1)?: 위의 코드는 중괄호 내의 내용을 반환하는 return {} 으로 고려했으나, 실제 동작은 return;으로 return 이후의 중괄호는 실행되지 않는다.

## 5.6 표현식인 문과 표현식이 아닌 문

표현식인 문과 표현식이 아닌 문을 구별한느 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다. 표현식인 문은 결과가 값이기 때문에 변수에 할당할 수 있으나 표현식이 아닌 문은 에러가 발생한다. 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데 이를 완료 값이라 한다. 완료 값은 표현식의 평가 결과가 아니다. 따라서 변수에 할당할 수 없고 참조할 수도 없다.

# **6장 데이터 타입**

데이터 타입 종류

| 구분 | 데이터 타입 | 설명 |
| --- | --- | --- |
| 원시 타입 | 숫자 타입 | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
|  | 문자열 타입 | 문자열 |
|  | 불리언 타입 | 논리적 참(true)와 거짓(false) |
|  | undefined 타입 | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
|  | null 타입 | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
|  | 심벌 타입 | ES6에서 추가된 7번째 타입 |
| 객체 타입 |  | 객체, 함수, 배열 등 |

## **6.1 숫자 타입**

`C`나 `java`의 경우 숫자도 `int`, `long`, `float`, `double` 등 과 같은 다양한 숫자 타입을 제공한다.

하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.

ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다.

즉, 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.

```tsx
// 모두 숫자 타입이다.
var integer = 10;    // 정수
var double = 10.12;  // 실수
var negative = -20;  // 음의 정수

var binary = 0b01000001; // 2진수
var octal = 0o101;       // 8진수
var hex = 0x41;          // 16진수
```

```tsx
// 표기법만 다를 뿐 모두 같은 값이다.
console.log(binary); // 65
console.log(octal);  // 65
console.log(hex);    // 65
console.log(binary === octal); // true
console.log(octal === hex);    // true
```

정수처럼 보이지만 실수로 처리된다.

```tsx
// 숫자 타입은 모두 실수로 처리된다.
console.log(1 === 1.0); // true
console.log(4 / 2);     // 2
console.log(3 / 2);     // 1.5
```

```tsx
// 숫자 타입의 세 가지 특별한 값
console.log(10 / 0);       // Infinity
console.log(10 / -0);      // -Infinity
console.log(1 * 'String'); // NaN
```

## **6.2 문자열 타입**

문자열 타입`string`은 텍스트 데이터를 나타내는데 사용한다.

문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자를 표현할수 있다.

문자열은 작은따옴표(`' '`), 큰따옴표(`" "`), 백틱(`` ``)으로 텍스트를 감싼다.

자바스크립트에서는 일반적으로 작은따옴표(`' '`)를 사용한다.

> 참고: 에어비엔비 JavaScript Style Guide
> 

```tsx
// 문자열 타입
var string;
string = '문자열'; // 작은따옴표
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱 (ES6)

string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식된다.";
```

참고 `C`는 문자열 타입을 제공하지 않고 문자의 배열로 문자열을 표현 자바는 문자열을 객체로 표현 자바스크립트는 문자열은 원시타입이며, 변경 불가능한 값`immutable value`이다

## **6.3 템플릿 리터럴**

ES6부터 도입된 표기법 `template literal`

템플릿 리터럴은 멀티라인 문자열`multi-line string`, 표현식 삽입`expression interpolation`, 태그드 템플릿`tagged template` 등 편리한 문자열 처리기능을 제공한다.

백틱(`` ``)을 사용해 표현한다.

```tsx
var template = `Template literal`;
console.log(template); // Template literal
```

### **6.3.1 멀티라인 문자열**

일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다.

하지만 템플릿 리터럴을 활용하면 줄바꿈도 포함할수 있다.

```tsx
var str = 'Hello
world.';
// SyntaxError: Invalid or unexpected token

var template = `Hello
world`;
console.log(template);
// Hello
// world
```

### **6.3.2 표현식 삽입**

문자열은 `+` 연산자를 사용해 연결 할 수 있는데,

템플릿 리터럴에 표현식 삽입을 통해 `+` 연산자를 사용하지 않고도 간단히 문자열을 연결 할 수 있다.

표현식을 삽입하려면 `${ }` 으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입된다.

```tsx
var first = 'Ung-mo';
var last = 'Lee';

// ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last + '.'); // My name is Ung-mo Lee.

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.

// 템플릿 리터럴 표현식 강제 형 변환
console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3

// 일반 문자열로 작성시 그냥 문자로 출력
console.log('1 + 2 = ${1 + 2}'); // 1 + 2 = ${1 + 2}
```

## **6.4 불리언 타입**

불리언 타입의 값은 true, false 뿐이다.

```tsx
var foo = true;
console.log(foo); // true

foo = false;
console.log(foo); // false
```

## **6.5 undefined 타입**

undefined 타입의 값은 `undefined`가 유일하다.

`var`키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화 된다.

변수를 선언한 이후 아무것도 할당하지 않은 변수를 참조하면 `undefined`가 반환된다.

```tsx
var foo;
console.log(foo); // undefined
```

## **6.6 null 타입**

`undefined`는 초기화 값이므로 의도적으로 `undefined`값을 할당한다면 본래 취지와 어긋나고 혼란을 줄 수 있으므로 권장하지 않는다.

따라서 변수에 값이 없다는 것을 명시하고 싶을 때는 `null`을 할당한다.

`null`을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.

```tsx
var foo = 'Lee';

// 이전에 할당되어 있던 값에 대한 참조를 제거. foo 변수는 더 이상 'Lee'를 참조하지 않는다.
// 유용해 보이지는 않는다. 변수의 스코프를 좁게 만들어 변수 자체를 재빨리 소멸시키는 편이 낫다.
foo = null;
```

## **6.7 심벌 타입**

ES6에 새롭게 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.

심벌 값은 다른 값과 중복되지 않는 유일 무이한 값이다.

그래서 보통 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용된다.

`Symbol`함수를 호출해 생성한다. 이때 생성된 심벌값은 외부에 노출되지 않으면, 다른값과 절대 중복되지 않는 유일무이한 값이다.

```tsx
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); // value

// 같은 형태로 생성해도 다른 값이다
Symbol('a') === Symbol('a') // false
```

## **6.8 객체 타입**

지금까지 살펴본 6가지 타입 이외의 값은 모두 객체 타입이다.

## **6.9 데이터 타입의 필요성**

- 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
- 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

## **6.10 동적 타이핑**

### **6.10.1 정적 타입 언어**

`C`나 `java`는 정적타입(`static type`)언어 이다. 따라서 변수를 선언할 때 어떤 타입인지 사전에 지정해 줘야 한다. 이를 명시적 타입 선언(`explicit type declaration`)이라 한다.

정적 타입 언어는 컴파일 시점에 타입체크를 수행한다. 만약 타입체크를 통과하지 못하면 에러를 발생시키고 컴파일이 안된다.

```c
// c 변수에는 1바이트 정수 타입의 값(-128 ~ 127)만을 할당할 수 있다.
char c;

// num 변수에는 4바이트 정수 타입의 값(-2,124,483,648 ~ 2,124,483,647)만을 할당할 수 있다.
int num;
```

### **6.10.2 동적 타입 언어**

이와 반대로 자바스크립트 언어는 변수를 선언할 때 타입을 선언하지 않는다. 다만 `var`, `let`, `const` 키워드를 사용해 변수를 선언 할 뿐이다.

자바스크립트의 변수는 정적 타입 언어와 같이 미리 선언한 데이터 타입의 값만 할당할 수 있는 것이 아니고, 어떤 데이터 타입이라도 자유롭게 할당할 수 있다. 아래 예제는 `var`로 선언한 `foo`변수에 어떤 타입이든 자유롭게 할당하는 것을 보여준다.

```jsx
var foo;
console.log(typeof foo);  // undefined

foo = 3;
console.log(typeof foo);  // number

foo = 'Hello';
console.log(typeof foo);  // string

foo = true;
console.log(typeof foo);  // boolean

foo = null;
console.log(typeof foo);  // object

foo = Symbol(); // 심벌
console.log(typeof foo);  // symbol

foo = {}; // 객체
console.log(typeof foo);  // object

foo = []; // 배열
console.log(typeof foo);  // object

foo = function () {}; // 함수
console.log(typeof foo);  // function
```

> 타입 추론(type inference) : 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정 된다.
> 

### **6.10.3 동적 타입 언어 장단점**

동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있어 데이터 타입에 대해 무감각해질 정도로 편리하다.

하지만 이로 인해 복잡한 프로그램에서는 변수 값을 추적하기 어렵다. 따라서 변수값을 확인하기 전에는 타입을 확신할 수 없다.

게다가 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 `암묵적 타입 변환`이 있어 개발자의 의도와 상관없이 타입이 바뀌어 프로그램이 오류를 뿜어 낼 수 도 있다.

> 동적 타입 언어 사용시 주의사항변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.변수의 유효 범위는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.전역 변수는 최대한 사용하지 않도록 한다.변수보다는 상수를 사용해 값의 변경을 억제한다.변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.
>