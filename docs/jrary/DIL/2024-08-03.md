# DIL: 모던 자바스크립트 Deep Dive

> 스터디: 월간 CS, https://github.com/monthly-cs/2024-07-modern-javascript-deep-dive  
> 작성일: 2024-08-03
> 작성자: jrary

---

# 14장 전역 변수의 문제점
## 14.1 변수의 생명 주기
### 14.1.1 지역 변수의 생명 주기

```js
function foo () {
    var x = 'local';
    console.log(x);
    return x;
}

foo();
console.log(x); // ReferenceError: x is not defined
```
함수 몸체의 다른 문들이 순차적으로 실행되기 이전에 함수 안에서 x 변수의 선언문이 자바스크립트 엔진에 의해 가장 먼저 실행되어 x 변수가 선언되고 undefined로 초기화된다.

지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.

### 14.1.2 전역 변수의 생명 주기

var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

## 14.2 전역 변수의 문제점
#### 암묵적 결합

코드 어디서든 전역 변수를 참조하고 변경할 수 있다. 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성이 높아진다.

#### 긴 생명 주기

전역 변수는 생명 주기가 길다. var 키워드는 변수의 중복 선언을 허용하므로 생명 주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있다.

#### 스코프 체인 상에서 종점에 존재

전역 변수는 스코프 체인 상에서 종점에 존재한다. 따라서 전역 변수의 검색 속도가 가장 느리다.

#### 네임스페이스 오염

자바스크립트는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수/함수가 같은 스코프 내에 존재할 수 있다.

## 14.3 전역 변수의 사용을 억제하는 방법
### 14.3.1 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

```js
(function() {
    var foo = 10;
    // 코드
}());

console.log(foo);
```

### 14.3.2 네임스페이스 객체

```js
var MYAPP = {};

MYAPP.person = {
    name: "Lee",
    address: "Seoul"
};

console.log(MYAPP.person.name);
```

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.

네임스페이스 객체 자체가 전역 변수에 할당되므로 유용하지는 않다.

### 14.3.3 모듈 패턴

코드 캡슐화를 통해 정보 은닉을 할 수 있지만, 자바스크립트는 public, private, protected 등의 접근 제한자를 제공하지 않는다. 

```js
var Counter = (function() {
    var num = 0;
    return {
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        }
    };
}());

console.log(Counter.num); // undefined - private 변수이므로 외부에 노출되지 않는다.

console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 2
console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 0
```

24장 클로저에서 더 자세히..

### 14.3.4. ES6 모듈

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 따라서 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니다.