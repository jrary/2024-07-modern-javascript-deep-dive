# DIL: 모던 자바스크립트 Deep Dive

> 스터디: 월간 CS, https://github.com/monthly-cs/2024-07-modern-javascript-deep-dive  
> 작성일: 2024-08-11
> 작성자: jrary

---

# 19장 프로토타입
## 19.1 객체지향 프로그래밍
## 19.2 상속과 프로토타입

> 자바스크립트는 프로토타입(prototype) 을 기반으로 상속을 구현한다.
> 
- 위에 예제에서 getArea 메서드 는 Circle 객체의 생성자 함수에 메서드로 등록한 것이 아닌, Circle 생성자 함수의 prototype 객체에 메서드로 등록한 것
    - 생성자 함수에 메서드로 등록할 경우 → 각각의 객체에 독립적인 동일한 기능을하는 메서드가 할당 → 메모리 소모
    - prototype 에 메서드로 등록할 경우 → 동일한 기능을 하는 하나의 메서드를 여러 객체가 공유 , 각각의 객체는 독립된 상태(state)만 관리할 수 있다.

> 모든 객체(인스턴스)는 자신의 프로토타입 , 즉 상위(부모) 객체 역할을 하는 prototype 의 모든 프로퍼티와 메서드를 상속받는다.
> 
- 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 가진다.
    - 이는 프로토타입의 참조값(null인 경우도 있음)
    - [[Prototype]] 에 저장되는 프로토타입은 객체 생성 방식 에 의해 결정
        - 예를 들어, 객체 리터럴( { } ) 로 생성된 객체의 프로토타입 → Object.prototype
        - 생성자 함수에 의해 생성된 객체의 프로토타입 → 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체
    - 모든 객체는 하나의 프로토타입을 갖는다.
        - 모든 프로토타입은 생성자 함수와 연결 되어 있다.
        - 즉, 객체 - 프로토타입 - 생성자 함수는 연결되어 있다.

> 자바스크립트는 프로토타입(prototype) 을 기반으로 상속을 구현한다.
> 
- 위에 예제에서 getArea 메서드 는 Circle 객체의 생성자 함수에 메서드로 등록한 것이 아닌, Circle 생성자 함수의 prototype 객체에 메서드로 등록한 것
    - 생성자 함수에 메서드로 등록할 경우 → 각각의 객체에 독립적인 동일한 기능을하는 메서드가 할당 → 메모리 소모
    - prototype 에 메서드로 등록할 경우 → 동일한 기능을 하는 하나의 메서드를 여러 객체가 공유 , 각각의 객체는 독립된 상태(state)만 관리할 수 있다.

## 19.3 프로토타입 객체

> 모든 객체(인스턴스)는 자신의 프로토타입 , 즉 상위(부모) 객체 역할을 하는 prototype 의 모든 프로퍼티와 메서드를 상속받는다.
> 
- 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 가진다.
    - 이는 프로토타입의 참조값(null인 경우도 있음)
    - [[Prototype]] 에 저장되는 프로토타입은 객체 생성 방식 에 의해 결정
        - 예를 들어, 객체 리터럴( { } ) 로 생성된 객체의 프로토타입 → Object.prototype
        - 생성자 함수에 의해 생성된 객체의 프로토타입 → 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체
    - 모든 객체는 하나의 프로토타입을 갖는다.
        - 모든 프로토타입은 생성자 함수와 연결 되어 있다.
        - 즉, 객체 - 프로토타입 - 생성자 함수는 연결되어 있다.

### 19.3.1 __proto__ 접근자 프로퍼티

- 모든 객체는 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.

![](https://user-images.githubusercontent.com/58619071/193441030-c547ddb6-b48b-44ed-aa65-bc3608d31c20.png)

#### __proto__는 접근자 프로퍼티이다.

- 자바스크립트는 원칙적으로 내부 슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 없지만, 일부 내부 슬롯과 내부 메서드에 한해 간접적으로 접근할 수 있도록 한다.
- [[Prototype]] 내부 슬롯에도 직접 접근할 수 없으나, __proto__를 통해 간접적으로 프로토타입에 접근한다.

#### __proto__ 접근자 프로퍼티는 상속을 통해 사용된다

- __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티이다.
- 모든 객체는 Object.property의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.

#### __proto__ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유

- 상호 첨조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함

```js
const parent = {};
const child = {};

child.__proto__ = parent;
parent.__proto__ = child;
```

- 프로토타입 체인은 단방향으로 링크되어야 한다.
- 위의 경우처럼 아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 __proto__ 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현된다.

#### __proto__ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.

- 모든 객체에 __proto__를 사용할 수 있는 것은 아님

```js
const obj = Object.create(null);
```

- obj는 프로토타입 체인의 종점이다. 따라서 Object.__proto__를 상속받을 수 없다.

### 19.3.2 함수 객체의 prototype 프로퍼티

- **함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.**

### 19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수

- 모든 프로토타입은 constructor 프로퍼티를 갖는다.

```js
function Person(name) {
    this.name = name;
}

const me = new Person('Lee');
console.log(me.constructor === Person); // true
```

- prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.
- me 객체의 생성자 함수는 Person이다.

## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다.
- 프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼티에 의해 연결되어 있다.
- 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.

## 19.5 프로토타입의 생성 시점

- 객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로, 모든 객체는 생성자 함수와 연결되어 있다.
- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

### 19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점

- constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

### 19.5.2 빌트인 생성자 함수와 프로토타입 생성 시점 
## 19.6 객체 생성 방식과 프로토타입의 결정
### 19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입
### 19.6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입
### 19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입
## 19.7 프로토타입 체인
## 19.8 오버라이딩과 프로퍼티 섀도잉
## 19.9 프로토타입의 교체
### 19.9.1 생성자 함수에 의한 프로토타입의 교체
### 19.9.2 인스턴스에 의한 프로토타입의 교체
## 19.10 instanceof 연산자
## 19.11 직접 상속
### 19.11.1 Object.create에 의한 직접 상속
### 19.11.2 객체 리터럴 내부에서 __proto__에 의한 직접 상속
## 19.12 정적 프로퍼티/메서드
## 19.13 프로퍼티 존재 확인
### 19.13.1 in 연산자
### 19.13.2 Object.prototype.hasOwnProperty 메서드
## 19.14 프로퍼티 열거
### 19.14.1 for...in 문
### 19.14.1 Object.keys/values/entries 메서드

# 21장
## 21.1 자바스크립트 객체의 분류
## 21.2 표준 빌트인 객체
## 21.3 원시값과 래퍼 객체
## 21.4 전역 객체
### 21.4.1 빌트인 전역 프로퍼티
### 21.4.2 빌트인 전역 함수
### 21.4.3 암묵적 전역